# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QLtop
                                 A QGIS plugin
 Outil interactif de préanalyse pour le logiciel LTOP
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2020-09-25
        git sha              : $Format:%H$
        copyright            : (C) 2020 by HEIG-VD | Nicolas Szakacs
        email                : nicolas.szakacs@heig-vd.ch
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; Version 3 of the License.               *
 *                                                                         *
 ***************************************************************************/
"""

# Usefull to translate encoding from Ainsi tu UTF-8
import codecs

from qgis.PyQt import QtSql
from qgis.PyQt.QtCore import Qt

from qgis.core import QgsProject

from qltop.pui.qltop_dat_fixed_points_dialog import *
from qltop.pui.qltop_relatives_point_dialog import *
from qltop.pui.qltop_group_dist_dir_dialog import *

# Import the core program
from qltop.core.database import *
from qltop.core.general_tools import *
from qltop.core.point_management import *


# Grey / light Grey color
stylesSheetDat = \
"""
QCommandLinkButton
{
background-color: #bbbbbb;
border-radius: 3px;
color: #fff;
}
QCommandLinkButton::hover
{
background-color: #d3d3d3;
}
QCommandLinkButton::pressed
{
background-color: #bbbbbb;
}
"""


def dat_maj_PF_in_Qgis(table_points, epsg):
    """
    Update the qltop point layer in the Qgis canevas
    only if he already exists
    """
    try:
        names = [layer.name() for layer in QgsProject.instance().mapLayers().values()]
        qgs_instance = QgsProject.instance()
        for name in names:
            if name == displayLayerPoint.layer_name:
                displayLayerPoint(table_points, epsg, "")  ## Create and display the point layer
    except:
        print("Dat management -> Failed to update the point layer in the Qgis canevas")


def dat_show_PF_dialog(db_name, epsg):
    """ Display the select fix point dialog box in the .DAT panel """
    dlg = datPfDialog(db_name)
    dlg.exec_()
    if dlg:
        # Update the point symbology in the Qgis canevas
        table_points = generalToolsDB.select_tbl_items(db_name, "point_pk")  ## Instance selection points in DB
        dat_maj_PF_in_Qgis(table_points, epsg)  ## Update the qltop point layer if already exist in canevas


def dat_show_reliability_dialog(db_name):
    """ Display the reliability relatives point dialog box in the .DAT panel """
    dlg = datRelDialog(db_name)
    dlg.exec_()


def dat_show_grp_dist_dir_dialog(db_name):
    """ Display the distance/direction group dialog box in the .DAT panel """
    dlg = datGrpDialog(db_name)
    dlg.exec_()


class loadDatConf:
    """
    Purpose :
         - Create a list of values from an existing Ltop.DAT configuration file
    Input :
        - Ltop.dat file
    Output :
        - List of KA attributes to write in the .DAT panel fields and in the db.qltop
    """

    def __init__(self, db_name, dat_path):
        self.db_name = db_name    ## Selected database name
        self.dat_path = dat_path  ## Ltop.Dat file name
        self.file_content = self.read_dat_file(self.dat_path)            ## Extract all file content
        self.var_point = self.extract_variable_point(self.file_content)  ## Extract variable point only
        self.pnt_reliab = self.extract_relative(self.file_content)       ## Extraction of relative reliability and the relative ellipse
        self.grp_dist = self.extract_grp_distance(self.file_content)     ## Extraction the distance groupe data
        self.grp_dir = self.extract_grp_direction(self.file_content)     ## Extraction the direction groupe data
        self.ka_no_descr = self.extract_ka_no_descr(self.file_content)
        self.ka_with_descr = self.extract_ka_with_descr(self.file_content)

        # update the database
        if self.var_point:
            manageDatDB.set_var_point(self.db_name, self.var_point)    ## Update db and assign variable/fixe to points
        if self.pnt_reliab:
            manageDatDB.set_rel_point(self.db_name, self.pnt_reliab)   ## Update db with relatives point
        if self.grp_dist:
            manageDatDB.set_grp_distance(self.db_name, self.grp_dist)  ## Update db with the distance group data
        if self.grp_dir:
            manageDatDB.set_grp_direction(self.db_name, self.grp_dir)  ## Update db with the direction group data

    @staticmethod
    def read_dat_file(filename):
        """ Read the Ltop.dat file and create a list of the content """
        try:
            with codecs.open(filename, "r", encoding="mbcs") as file:    ## mbcs = 'codecs' module 'ainsi' encoding equivalent
                lines = file.read().splitlines()                         ## read each lines
                lines = filter(lambda x: x.strip(), lines)               ## remove empty lines
                lines = filter(lambda x: not x.startswith(";"), lines)   ## remove commentary lines ";"
            return list(lines)
        except:
            print("Dat management -> Failed to read the Ltop.dat file")

    @classmethod
    def extract_grp_distance(cls, file_content):
        """
        Extract the distance group data
        - KA 06 = DIST.GR.
        """
        grp_dist = []  ## return list
        for row in file_content:
            if row[:10] == "06DIST.GR.":
                grp_dist.append([row[16], row[27], row[28],
                                 cls.extract_ka_pos(row, 34, 41, 41, 45),
                                 row[49:57].rstrip(),
                                 cls.extract_ka_pos(row, 57, 59, 59, 61),
                                 cls.extract_ka_pos(row, 63, 65, 65, 67)])
        return grp_dist

    @classmethod
    def extract_grp_direction(cls, file_content):
        """
        Extract the direction group data
        - KA 06 = DIR
        """
        grp_dir = []  ## return list
        for row in file_content:
            if row[:4] == "06RI":
                grp_dir.append([row[16],
                                cls.extract_ka_pos(row, 22, 29, 29, 33)])
        return grp_dir

    @staticmethod
    def extract_variable_point(file_content):
        """
        Extract the variable point to update the database
        - KA 30 = plani
        - KA 35 = alti
        """
        var_plani = []  ## list of planimetric variable point
        var_alti = []   ## list of altimetric variable point
        var_point = {}  ## return dictionary
        for row in file_content:
            if row[:2] == "30":
                var_plani.append([row[2:12].rstrip()])
            if row[:2] == "35":
                var_alti.append([row[2:12].rstrip()])
        var_point["var_plani"] = var_plani
        var_point["var_alti"] = var_alti
        return var_point

    @staticmethod
    def extract_relative(file_content):
        """
        Extraction of relative reliability and the relative ellipse
        - KA 50 = relative ellipse
        - KA 60 = relative reliability
        """
        pnt_ellips = []  ## list of relative ellipse, first and second point
        pnt_fiabil = []  ## list of relative reliability, first and second point
        pnt_reliab = {}  ## return dictionary
        for row in file_content:
            if row[:2] == "50":
                pnt_ellips.append([row[2:12].rstrip(),
                                   row[12:16].rstrip(),
                                   row[16:26].rstrip(),
                                   row[26:30].rstrip()])
            if row[:2] == "60":
                pnt_fiabil.append([row[2:12].rstrip(),
                                   row[12:16].rstrip(),
                                   row[16:26].rstrip(),
                                   row[26:30].rstrip()])
        pnt_reliab["pnt_ellips"] = pnt_ellips
        pnt_reliab["pnt_fiabil"] = pnt_fiabil
        return pnt_reliab

    @classmethod
    def extract_ka_no_descr(cls, file_content):
        """
        Extract all the line data without a description parameter
        - KA : OF, 00, 13, 20
        - KA IF is managed by the .KOO and .MES tabs, not the Ltop.dat file
        """
        ka_00 = []    ## Title
        ka_13 = []    ## ???? -> no description
        ka_20 = []    ## Ref. point
        ka_data = {}  ## return dictionary
        for row in file_content:
            # KA IF = Header
            if row[:2] == "IF" or row[:2] == "OF":
                ka_data[row[:2]] = row.split()[1:]
            # KA 00 = Titles
            if row[:2] == "00":
                ka_00.append(row.rstrip()[2:])
            ka_data["00"] = ka_00
            # ? -> no description
            if row[:2] == "13":
                ka_13.append(cls.extract_ka_pos(row, 10, 17, 17, 21))  ## Param 2
                ka_13.append(cls.extract_ka_pos(row, 22, 29, 29, 31))  ## Param 3
                ka_13.append(row[40])  ## Param 4
            ka_data["13"] = ka_13
            # KA 20 = Ref. point
            if row[:2] == "20":
                ka_20.append(row[2:10].rstrip())  ## Param 1
                ka_20.append(cls.extract_ka_pos(row, 10, 17, 17, 21))  ## Param 2
                ka_20.append(cls.extract_ka_pos(row, 22, 29, 29, 33))  ## Param 3
                ka_20.append(cls.extract_ka_pos(row, 34, 41, 41, 45))  ## Param 4
            ka_data["20"] = ka_20
        return ka_data

    @classmethod
    def extract_ka_with_descr(cls, file_content):
        """
        Extract all the line data with a description parameter
        - KA : 01, 02, 03, 04, 05, 06RI, 07, 08, 09, 10, 11, 12, 14KOO.VERZ, 14PLOT, 15, 16
        """
        ka_data = {}    ## return dictionary
        for row in file_content:
            # KA 01 KAT
            if row[:7] == "01KOORD":
                ka_data["01KOORD"] = [row[16],
                                      cls.extract_ka_pos(row, 22, 29, 29, 33),
                                      cls.extract_ka_pos(row, 34, 41, 41, 45),
                                      cls.extract_ka_pos(row, 57, 59, 59, 61),
                                      cls.extract_ka_pos(row, 63, 65, 65, 67),
                                      row[70:74].replace(" ", ""),
                                      row[75:79].replace(" ", "")]
            if row[:9] == "01RUNDUNG":
                ka_data["01RUNDUNG"] = [row[16], cls.extract_ka_pos(row, 22, 29, 29, 33)]
            if row[:5] == "01KAT":
                ka_data["01KAT"] = [row[16], row[28]]
            # KA 02, 03
            if row[:2] == "02" or row[:2] == "03":
                ka_data[row[:2]] = row[15:17].replace(" ", "")
            # KA 04, 05, 10
            if row[:2] == "04" or row[:2] == "05" or row[:2] == "10":
                ka_data[row[:2]] = cls.extract_ka_pos(row, 10, 17, 17, 21)
            # KA 07, 09, 11, 12
            if row[:2] == "07" or row[:2] == "09" or row[:2] == "11" or row[:2] == "12":
                ka_data[row[:2]] = [cls.extract_ka_pos(row, 10, 17, 17, 21),
                                    cls.extract_ka_pos(row, 22, 29, 29, 33)]
            # KA 08 DIST.RED
            if row[:2] == "08":
                ka_data[row[:2]] = [cls.extract_ka_pos(row, 10, 17, 17, 21),
                                    row[28],
                                    cls.extract_ka_pos(row, 34, 41, 41, 45),
                                    row[49:57].rstrip(),
                                    cls.extract_ka_pos(row, 57, 59, 59, 61)]
            # KA 14 KOO.VERZ
            if row[:10] == "14KOO.VERZ":
                ka_data["14KOO.VERZ"] = [row[16], row[28], row[40],
                                         row[49:57].rstrip(),
                                         row[58], row[64]]
            # KA 14 PLOT
            if row[:6] == "14PLOT":
                ka_data["14PLOT"] = [row[16],
                                     row[22:29].replace(" ", ""),
                                     cls.extract_ka_pos(row, 34, 41, 41, 45),
                                     row[58],
                                     row[63:69].replace(" ", ""),
                                     row[70:75].replace(" ", ""),
                                     cls.extract_ka_pos(row, 75, 79, 79, 80)]
            # KA 15 MATRIZEN
            if row[:2] == "15":
                ka_data[row[:2]] = [row[16], row[28]]
            # KA 16 PRAEANA.
            if row[:2] == "16":
                ka_data["16"] = row[16]
            # KA 17 PROGVERS
            if row[:10] == "17PROGVERS":
                ka_data["17PROGVERS"] = [row[16], row[28], row[40],
                                         row[57:59].replace(" ", "")]
            # KA 17 ELLIPSOI
            if row[:10] == "17ELLIPSOI":
                ka_data["17ELLIPSOI"] = [row[16],
                                         cls.extract_ka_pos(row, 22, 29, 29, 33),
                                         "{0:.13f}".format(float(row[34:45])/10**13),
                                         row[48:56].rstrip()]
            # KA 17 ROBUST
            if row[:8] == "17ROBUST":
                ka_data["17ROBUST"] = [cls.extract_ka_pos(row, 10, 17, 17, 21),
                                       cls.extract_ka_pos(row, 22, 29, 29, 33)]
            # KA 18 FIAB
            if row[:10] == "18I.ZUVERL":
                ka_data["18I.ZUVERL"] = [cls.extract_ka_pos(row, 22, 29, 29, 33),
                                         cls.extract_ka_pos(row, 38, 41, 41, 44),
                                         cls.extract_ka_pos(row, 63, 65, 65, 67),
                                         cls.extract_ka_pos(row, 71, 74, 74, 75),
                                         cls.extract_ka_pos(row, 76, 79, 79, 80)]
            # KA 18 FIAB
            if row[:6] == "18FIAB":
                ka_data["18FIAB"] = [row[16], row[22:29].replace(" ", "")]
        return ka_data

    @staticmethod
    def extract_ka_pos(row, sleft, eleft, sright, eright):
        """ Extract the ka param from the column left and right column align """
        left = row[int(sleft):int(eleft)].replace(" ", "")
        right = row[int(sright):int(eright)].replace(" ", "")
        val = left + (("." + right) if right else "")
        return val


class exportDatFile:
    """
    Purpose :
         - Export the Ltop configuration from the qltop database to an Ltop.DAT file
    Input :
        - qltop database name
        - Ltop.dat file path to be updated
    Output :
        - Ltop.dat file
    """
    def __init__(self, db_name, dat_file):
        self.db_name = db_name      ## Selected database name
        self.dat_file = dat_file    ## Selected Ltop.dat file
        self.total_rows_list = self.extract_all_data(self.db_name)  ## List of all rows to write
        self.write_dat_file(self.dat_file, self.total_rows_list)

    def extract_all_data(self, db_name):
        # Extract data from the database
        dat_conf = generalToolsDB.select_tbl_items(db_name, "dat_conf")
        grp_distance = generalToolsDB.select_tbl_items(db_name, "grp_distance")
        grp_direction = generalToolsDB.select_tbl_items(db_name, "grp_direction")
        point_pk = generalToolsDB.select_tbl_items(db_name, "point_pk")
        rel_ellips = generalToolsDB.select_tbl_items(db_name, "rel_ellips")
        rel_fiab = generalToolsDB.select_tbl_items(db_name, "rel_fiab")
        # Create the Ltop.dat rows
        row_dat_conf = self.row_dat_conf(dat_conf)           ## all other single KA
        row_grp_dist = self.row_grp_distance(grp_distance)   ## KA 06 DIST.GR.
        row_grp_dir = self.row_grp_direction(grp_direction)  ## KA 06 RI
        row_var_point = self.row_variable_point(point_pk)    ## KA 30, 35
        row_ellips = self.row_reliability_point(rel_ellips)  ## KA 50
        row_fiab = self.row_reliability_point(rel_fiab)      ## KA 60
        # Concatenate all rows in one single list ready to write in the Ltop.dat file
        return self.concatenate_row_list(row_dat_conf, row_grp_dist,
                                         row_grp_dir, row_var_point,
                                         row_ellips, row_fiab)

    @staticmethod
    def concatenate_row_list(row_dat_conf, row_grp_dist,
                             row_grp_dir, row_var_point, row_ellips, row_fiab):
        """ Concatenate all the Ltop configuration lists in a single one """
        # Concatenate the lists
        res_list = row_dat_conf + row_var_point + row_ellips + row_fiab
        # Insert the KA 06 DIST.GR. AND RI lists
        idx_ins = [idx for idx, row in enumerate(row_dat_conf) if "05HOEHEABB" in row][0] + 1  ## index to insert lists
        res_list[idx_ins:idx_ins] = row_grp_dist + row_grp_dir
        # Finition
        res_list.append("97ENDE" + " "*74)
        return res_list

    @staticmethod
    def write_dat_file(filename, total_rows_list):
        """
        Write the all the configuration rows in the selected Ltop.dat file
        -> Overwrites existing content
        """
        try:
            with codecs.open(filename, "w", encoding="mbcs") as file:    ## mbcs = 'codecs' module 'ainsi' encoding equivalent
                items = list(map(lambda x: x + "\r\n", total_rows_list))  ## Add break line at the end of each line
                file.writelines(items)
            iface.messageBar().pushMessage("Info : ",
                                           u"*** Mise jour du fichier '{}' effectué avec succès ***".format(filename),
                                           level=Qgis.Success,
                                           duration=2)
        except:
            iface.messageBar().pushMessage("Attention : ",
                                           u"*** La mise jour du fichier '{}' a échoué ***".format(filename),
                                           level=Qgis.Warning,
                                           duration=3
                                           )
            print("Dat management -> Failed to write the Ltop configuration rows in the selected Ltop.Dat file.")

    @classmethod
    def row_variable_point(cls, data):
        """
        Create an Ltop.DAT line for the variable point data
        qltop database -> 'point_pk' table
        """
        lst_plani = []
        lst_alti = []
        res_list = []
        for item in data:
            if item[2] == 1:  ## 1 = Variable plani, KA 30
                lst_plani.append("30" + cls.empty_space(item[1], 78, "left"))
            if item[3] == 1:  ## 1 = Variable alti, KA 35
                lst_alti.append("35" + cls.empty_space(item[1], 78, "left"))
        res_list = lst_plani + lst_alti
        return res_list

    @classmethod
    def row_reliability_point(cls, data):
        """
        Create an Ltop.DAT line for the ellipse or fiability data
        qltop database -> 'rel_ellips' or 'rel_fiab' tables
        """
        res_list = []
        for item in data:
            mod_item = [str(i or "") for i in item]  ## Replace None value by empty string ""
            row = mod_item[1]
            row += cls.empty_space(mod_item[2], 10, "left")
            row += cls.empty_space(mod_item[3], 4, "left")
            row += cls.empty_space(mod_item[4], 10, "left")
            row += cls.empty_space(mod_item[5], 4, "left")
            row += " "*50
            res_list.append(row)
        return res_list

    @classmethod
    def row_grp_distance(cls, data):
        """
        Create an Ltop.DAT line for the distance groupe data
        qltop database -> 'grp_distance' table, KA
        """
        res_list = []
        for item in data:
            row = item[1] + item[2] + " "*6
            row += cls.empty_space(item[3], 1, "left") + " "*10
            row += cls.empty_space(item[4], 1, "left")
            row += cls.empty_space(item[5], 1, "left") + " "*5
            row += cls.split_item_decimal(item[6], 7, 2) + " "*6
            row += cls.empty_space(item[7], 8, "left")
            row += cls.split_item_decimal(item[8], 2, 2) + " "*2
            row += cls.split_item_decimal(item[9], 2, 2) + " "*13
            res_list.append(row)
        return res_list

    @classmethod
    def row_grp_direction(cls, data):
        """
        Create an Ltop.DAT line for the direction groupe data
        qltop database -> 'grp_direction' table
        """
        res_list = []
        for item in data:
            row = item[1] + item[2] + " "*12
            row += cls.empty_space(item[3], 1, "left") + " "*5
            row += cls.split_item_decimal(item[4], 7, 2) + " "*49
            res_list.append(row)
        return res_list

    @classmethod
    def row_dat_conf(cls, data):
        """
        Create an Ltop.DAT line for the main KA content data
        qltop database -> 'dat_conf' table
        """
        res_list = []
        for item in data:  ## KA IF, OF, 00 - 05, 07 - 20
            if item[1] == "IF":
                tmp_if = item[1] + " " + item[2] + " " + item[3]
                res_if = tmp_if + " "*(80-len(tmp_if))
                res_list.append(res_if)
            if item[1] == "OF":
                tmp_of = item[1] + " " + item[2] + " " + item[3] + " " + item[4]
                res_of = tmp_of + " "*(80-len(tmp_of))
                res_list.append(res_of)
            if item[1] == "00":
                tmp_00_1 = item[1] + item[2]  ## Title 1
                res_00_1 = tmp_00_1 + " "*(80-len(tmp_00_1))
                res_list.append(res_00_1)
                tmp_00_2 = item[1] + item[3]  ## Title 2, mandatory line even if empty
                res_00_2 = tmp_00_2 + " "*(80-len(tmp_00_2))
                res_list.append(res_00_2)
            if item[2] == "KOORD":
                res_01_1 = item[1] + item[2] + " "*9 + item[3] + " "*5
                res_01_1 += cls.split_item_decimal(item[4], 7, 2) + " "*3
                res_01_1 += cls.split_item_decimal(item[5], 7, 2) + " "*14
                res_01_1 += cls.split_item_decimal(item[6], 2, 2) + " "*2
                res_01_1 += cls.split_item_decimal(item[7], 2, 2) + " "*3
                res_01_1 += cls.empty_space(item[8], 4, "left") + " "*1
                res_01_1 += cls.empty_space(item[9], 4, "left") + " "*1
                res_list.append(res_01_1)
            if item[2] == "RUNDUNG":
                res_01_2 = item[1] + item[2] + " "*7 + item[3] + " "*5
                res_01_2 += cls.split_item_decimal(item[4], 7, 2) + " "*49
                res_list.append(res_01_2)
            if item[2] == "KAT":
                res_01_3 = item[1] + item[2] + " "*11 + item[3]
                res_01_3 += " "*11 + item[4] + " "*51
                res_list.append(res_01_3)
            if item[2] == "LAGEITER" or item[2] == "HOEHEITE":
                res_02_03 = item[1] + item[2] + " "*5
                res_02_03 += cls.empty_space(item[3], 2, "right") + " "*63
                res_list.append(res_02_03)
            if item[2] == "LAGE ABB" or item[2] == "HOEHEABB":
                res_04_05 = item[1] + item[2]
                res_04_05 += cls.split_item_decimal(item[3], 7, 2) + " "*61
                res_list.append(res_04_05)
            if item[2] == "MF RI+AZ":
                res_07 = item[1] + item[2]
                res_07 += cls.split_item_decimal(item[3], 7, 2) + " "*3
                res_07 += cls.split_item_decimal(item[4], 7, 2) + " "*49
                res_list.append(res_07)
            if item[2] == "DIST.RED":
                res_08 = item[1] + item[2]
                res_08 += cls.split_item_decimal(item[3], 7, 2) + " "*9
                res_08 += cls.empty_space(item[4], 1, "left") + " "*5
                res_08 += cls.split_item_decimal(item[5], 7, 2) + " "*6
                res_08 += cls.empty_space(item[6], 8, "left")
                res_08 += cls.split_item_decimal(item[7], 2, 2) + " "*19
                res_list.append(res_08)
            if item[2] == "MF H.DIS":
                res_09 = item[1] + item[2]
                res_09 += cls.split_item_decimal(item[3], 7, 2) + " "*3
                res_09 += cls.split_item_decimal(item[4], 7, 2) + " "*49
                res_list.append(res_09)
            if item[2] == "MF HW":
                res_10 = item[1] + item[2] + " "*3
                res_10 += cls.split_item_decimal(item[3], 7, 2) + " "*61
                res_list.append(res_10)
            if item[2] == "MF IH-SH":
                res_11 = item[1] + item[2]
                res_11 += cls.split_item_decimal(item[3], 7, 2) + " "*3
                res_11 += cls.split_item_decimal(item[4], 7, 2) + " "*49
                res_list.append(res_11)
            if item[2] == "REFRAKT.":
                res_12 = item[1] + item[2]
                res_12 += cls.split_item_decimal(item[3], 7, 3) + " "*2
                res_12 += cls.split_item_decimal(item[4], 7, 3) + " "*48
                res_list.append(res_12)
            if item[1] == "13":
                res_13 = item[1] + " "*8
                res_13 += cls.split_item_decimal(item[3], 7, 4) + " "*1
                res_13 += cls.split_item_decimal(item[4], 7, 2) + " "*9
                res_13 += item[5] + " "*39
                res_list.append(res_13)
            if item[2] == "KOO.VERZ":
                res_14_1 = item[1] + item[2] + " "*6
                res_14_1 += item[3] + " "*11 + item[4] + " "*11 + item[5] + " "*8
                res_14_1 += cls.empty_space(item[6], 8, "left") + " "*1
                res_14_1 += item[7] + " "*5 + item[8] + " "*15
                res_list.append(res_14_1)
            if item[2] == "PLOT":
                res_14_2 = item[1] + item[2] + " "*10
                res_14_2 += item[3] + " "*5 + cls.empty_space(item[4], 7, "right") + " "*5
                res_14_2 += cls.split_item_decimal(item[5], 7, 4) + " "*13
                res_14_2 += item[6] + " "*4 + cls.empty_space(item[7], 6, "left") + " "*1
                res_14_2 += cls.split_item_decimal(item[8], 4, 1)
                res_14_2 += cls.split_item_decimal(item[9], 3, 1)
                res_list.append(res_14_2)
            if item[2] == "MATRIZEN":
                res_15 = item[1] + item[2] + " "*6
                res_15 += item[3] + " "*11 + item[4] + " "*51
                res_list.append(res_15)
            if item[2] == "PRAEANA.":
                res_16 = item[1] + item[2] + " "*6 + item[3] + " "*63
                res_list.append(res_16)
            if item[2] == "PROGVERS":
                res_17_1 = item[1] + item[2] + " "*6 + item[3] + " "*11
                res_17_1 += item[4] + " "*11 + item[5] + " "*16
                res_17_1 += cls.empty_space(item[6], 2, "right") + " "*21
                res_list.append(res_17_1)
            if item[2] == "ELLIPSOI":
                res_17_2 = item[1] + item[2] + " "*6 + item[3] + " "*5
                res_17_2 += cls.split_item_decimal(item[4], 7, 4) + " "*1
                res_17_2 += cls.calc_excentricite(item[5]) + " "*3
                res_17_2 += cls.empty_space(item[6], 8, "left") + " "*24
                res_list.append(res_17_2)
            if item[2] == "ROBUST":
                res_17_3 = item[1] + item[2] + " "*2
                res_17_3 += cls.split_item_decimal(item[3], 7, 2) + " "*3
                res_17_3 += cls.split_item_decimal(item[4], 7, 2) + " "*49
                res_list.append(res_17_3)
            if item[2] == "I.ZUVERL":
                res_18_1 = item[1] + item[2] + " "*12
                res_18_1 += cls.split_item_decimal(item[3], 7, 2) + " "*7
                res_18_1 += cls.split_item_decimal(item[4], 3, 1) + " "*21
                res_18_1 += cls.split_item_decimal(item[5], 2, 2) + " "*4
                res_18_1 += cls.split_item_decimal(item[6], 3, 1) + " "*1
                res_18_1 += cls.split_item_decimal(item[7], 3, 1)
                res_list.append(res_18_1)
            if item[2] == "FIAB":
                res_18_2 = item[1] + item[2] + " "*10
                res_18_2 += item[3] + " "*5
                res_18_2 += cls.empty_space(item[4], 7, "right") + " "*51
                res_list.append(res_18_2)
            if item[1] == "20":
                res_20 = item[1] + cls.empty_space(item[2], 8, "left")
                res_20 += cls.split_item_decimal(item[3], 7, 4) + " "*1
                res_20 += cls.split_item_decimal(item[4], 7, 4) + " "*1
                res_20 += cls.split_item_decimal(item[5], 7, 4) + " "*35
                res_list.append(res_20)
        return res_list

    @staticmethod
    def empty_space(data, length_must, alignment):
        """ Concatenates empty spaces to a string relative to a given length and an alignment """
        if data is not None:
            length_have = len(data)
            val = data
        else:
            length_have = 0
            val = ""
        hole_length = length_must - length_have
        empty_space = " " * hole_length
        res_string = ""
        if alignment == "left":
            res_string = val + empty_space
        else:
            res_string = empty_space + val
        return res_string

    @classmethod
    def split_item_decimal(cls, data, left_space, right_space):
        """ Split string with decimal value and concatenate empty space """
        if data is not None:
            data_split = data.split(".")
            left_part = cls.empty_space(data_split[0], left_space, "right")
            right_part = cls.empty_space(data_split[1], right_space, "left") if len(data_split) > 1 else " "*right_space
            return left_part + right_part
        else:
            return " "*left_space + " "*right_space

    @staticmethod
    def calc_excentricite(data):
        """
        Return extracted value for the first eccentricity of the ellipsoid
        Due to the specific geosuite format !
        """
        power = str(int(float(data)*10**13))
        val = ""
        if len(power) < 11:
            val = power + "0"*(11-len(power))
        elif len(power) > 11:
            val = power[0:11]
        else:
            val = power
        return val
