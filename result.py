# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QLtop
                                 A QGIS plugin
 Outil interactif de préanalyse pour le logiciel LTOP
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2020-09-25
        git sha              : $Format:%H$
        copyright            : (C) 2020 by HEIG-VD | Nicolas Szakacs
        email                : nicolas.szakacs@heig-vd.ch
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; Version 3 of the License.               *
 *                                                                         *
 ***************************************************************************/
"""

import os
# filesystem paths normalization
from pathlib import Path

# XML file management
import xml.etree.ElementTree as ET

from qgis.utils import iface

from qgis.PyQt import QtCore, QtSql, QtWidgets, QtGui
from qgis.PyQt.QtCore import Qt
from qgis.PyQt.QtWidgets import QSizePolicy

# Used to create a Qgis temporary layer
from qgis.PyQt.QtCore import QVariant, Qt
from qgis.PyQt import QtSql
from qgis.core import QgsVectorLayer, QgsField, QgsFeature,\
                      QgsGeometry, QgsPoint, QgsPointXY, QgsProject,\
                      QgsEllipse, QgsRectangle

from qltop.core.general_tools import *


class loadPrnx:
    """
    Purpose :
        - Extract the data from the Ltop.prnx file (xml format)
        - Will be displayed as tables in the 'result' tab from the 'qltop_dockwidget.py' functions
    Input :
        - Ltop.prnx file
    Output :
        - dictionary with the nodes and associates attributes
    """

    def __init__(self, prnx_file):
        self.prnx_file = prnx_file
        self.root = ET.parse(self.prnx_file).getroot()
        self.resultat = {}

        self.get_ltop_errors(self.root)
        self.get_header(self.root)
        self.get_planimetric_abriss(self.root)
        self.get_altimetric_abriss(self.root)
        self.get_coordinates(self.root)
        self.get_external_reliability_apriori(self.root)
        self.get_statistic(self.root)
        self.get_relative_ellipse(self.root)
        self.get_relative_rectangle(self.root)

    def get_ltop_errors(self, root):
        """ Get the ltop errors nodes data """
        try:
            list_ltop_error = []
            for node in root.findall("LTOPError"):
                node_ltop_error = []
                for key, value in node.attrib.items():
                    node_ltop_error.append(value)
                list_ltop_error.append(node_ltop_error)
            self.resultat["errors"] = list_ltop_error
        except:
            print("Result -> Error to import data from the node 'LTOPError'")

    def get_header(self, root):
        """ Get the header nodes data """
        try:
            dict_header = {}
            search_header = ["title", "title2", "date", "version", "progvers"]
            for item in search_header:
                for node in root.findall("header"):
                    dict_header[item] = node.find(item).text
            for node in root.findall("header"):
                for elem in node.findall("variablePoints"):
                    tag = elem.attrib["type"]
                    val = elem.text
                    dict_header[tag] = val
            self.resultat["header"] = dict_header
        except:
            print("Result -> Error to import data from the node 'header'")

    def get_planimetric_abriss(self, root):
        """ Get the planimetric abriss nodes data """
        try:
            # Stochastic model
            list_plani_mean_error = []
            for node in root.findall("planimetricAbriss/meanErrors/meanError"):
                node_plani_mean_error = []
                for key, value in node.attrib.items():
                    node_plani_mean_error.append(value)
                if "centeringErr" not in node.attrib:
                    node_plani_mean_error.insert(3, "")
                if "a" not in node.attrib:
                    node_plani_mean_error.insert(4, "")
                if "b" not in node.attrib:
                    node_plani_mean_error.insert(5, "")
                if "c" not in node.attrib:
                    node_plani_mean_error.insert(6, "")
                if "me1km" not in node.attrib:
                    node_plani_mean_error.insert(7, "")
                list_plani_mean_error.append(node_plani_mean_error)
            self.resultat["plani_meanError"] = list_plani_mean_error
        except:
            print("Result -> Error to import data from the node 'planimetricAbriss/meanErrors/meanError'")

        try:
            # Planimetric observation
            list_plani_station = []
            for station in root.findall("planimetricAbriss/station"):
                detail_obs_station = []
                detail_station = {}
                for key, value in station.attrib.items():
                    detail_station[key] = value
                detail_obs_station.append(detail_station)
                list_obs = []
                for obs in station:
                    single_obs = []
                    for key, value in obs.attrib.items():
                        single_obs.append(value)
                    if "corr" not in obs.attrib:
                        single_obs.insert(7, "")
                    list_obs.append(single_obs)
                detail_obs_station.append(list_obs)
                list_plani_station.append(detail_obs_station)
            self.resultat["plani_station"] = list_plani_station
        except:
            print("Result -> Error to import data from the node 'planimetricAbriss/station'")

        try:
            # Statistics WI
            dict_plani_biggestWi = {}
            for node in root.findall("planimetricAbriss/statistics"):
                biggestWi = node.find("biggestWi")
                if biggestWi is not None:
                    for key, value in biggestWi.attrib.items():
                        dict_plani_biggestWi[key] = value
                    if "biggestValueDet" not in dict_plani_biggestWi:
                        dict_plani_biggestWi["biggestValueDet"] = ""
                    if "biggestValueDetAT" not in dict_plani_biggestWi:
                        dict_plani_biggestWi["biggestValueDetAT"] = ""
            self.resultat["plani_biggestWi"] = dict_plani_biggestWi
        except:
            print("Result -> Error to import data from the node 'planimetricAbriss/statistics/biggestWi'")

        try:
            # List WI
            list_plani_listWi = []
            for wi in root.findall("planimetricAbriss/statistics/listWi/wi"):
                node_plani_listWi = []
                for key, value in wi.attrib.items():
                    node_plani_listWi.append(value)
                list_plani_listWi.append(node_plani_listWi)
            self.resultat["plani_listWi"] = list_plani_listWi
        except:
            print("Result -> Error to import data from the node 'planimetricAbriss/statistics/listWi/wi'")

        try:
            # Statistic characteristics
            dict_plani_charac = {}
            for node in root.findall("planimetricAbriss/statistics"):
                characteristics = node.find("characteristics")
                if characteristics is not None:
                    for key, value in characteristics.attrib.items():
                        dict_plani_charac[key] = value
            self.resultat["plani_characteristics"] = dict_plani_charac
        except:
            print("Result -> Error to import data from the node 'planimetricAbriss/statistics/characteristics'")

    def get_altimetric_abriss(self, root):
        """ Get the altimetric nodes data """
        try:
            # Stochastic model
            list_alti_mean_error = []
            for node in root.findall("altimetricAbriss/meanErrors/meanError"):
                node_plani_mean_error = []
                for key, value in node.attrib.items():
                    node_plani_mean_error.append(value)
                list_alti_mean_error.append(node_plani_mean_error)
            self.resultat["alti_meanError"] = list_alti_mean_error
        except:
            print("Result -> Error to import data from the node 'altimetricAbriss/meanErrors/meanError'")

        try:
            # Refraction coefficient and factorOneSidedSightings
            dict_altimetric_divers = {}
            search_header = ["refractionCoeff", "factorOneSidedSightings"]
            for item in search_header:
                for node in root.findall("altimetricAbriss/meanErrors"):
                    dict_altimetric_divers[item] = node.find(item).text
            self.resultat["alti_divers"] = dict_altimetric_divers
        except:
            print("Result -> Error to import data from the node 'altimetricAbriss/meanErrors/refractionCoeff,factorOneSidedSightings'")

        try:
            # Altimetric observation
            list_alti_station = []
            for station in root.findall("altimetricAbriss/station"):
                detail_obs_station = []
                detail_station = {}
                for key, value in station.attrib.items():
                    detail_station[key] = value
                detail_obs_station.append(detail_station)
                list_obs = []
                for obs in station:
                    single_obs = []
                    for key, value in obs.attrib.items():
                        single_obs.append(value)
                    if "control" not in obs.attrib:
                        single_obs.insert(5, "")
                    list_obs.append(single_obs)
                detail_obs_station.append(list_obs)
                list_alti_station.append(detail_obs_station)
            self.resultat["alti_station"] = list_alti_station
        except:
            print("Result -> Error to import data from the node 'altimetricAbriss/station'")

        try:
            # Statistics WI
            dict_alti_biggestWi = {}
            for node in root.findall("altimetricAbriss/statistics"):
                biggestWi = node.find("biggestWi")
                if biggestWi is not None:
                    for key, value in biggestWi.attrib.items():
                        dict_alti_biggestWi[key] = value
                    if "biggestValueDet" not in dict_alti_biggestWi:
                        dict_alti_biggestWi["biggestValueDet"] = ""
                    if "biggestValueDetAT" not in dict_alti_biggestWi:
                        dict_alti_biggestWi["biggestValueDetAT"] = ""
            self.resultat["alti_biggestWi"] = dict_alti_biggestWi
        except:
            print("Result -> Error to import data from the node 'altimetricAbriss/statistics/biggestWi'")

        try:
            # List WI
            list_alti_listWi = []
            for wi in root.findall("altimetricAbriss/statistics/listWi/wi"):
                node_alti_listWi = []
                for key, value in wi.attrib.items():
                    node_alti_listWi.append(value)
                list_alti_listWi.append(node_alti_listWi)
            self.resultat["alti_listWi"] = list_alti_listWi
        except:
            print("Result -> Error to import data from the node 'altimetricAbriss/statistics/listWi/wi'")

        try:
            # Statistic characteristics
            dict_alti_charac = {}
            for node in root.findall("altimetricAbriss/statistics"):
                characteristics = node.find("characteristics")
                if characteristics is not None:
                    for key, value in characteristics.attrib.items():
                        dict_alti_charac[key] = value
            self.resultat["alti_characteristics"] = dict_alti_charac
        except:
            print("Result -> Error to import data from the node 'altimetricAbriss/statistics/characteristics'")

    def get_coordinates(self, root):
        """ Get the coordinates nodes data """
        try:
            list_coordinates = []
            for node in root.findall("coordinates/point"):
                node_coordinates = []
                for key, value in node.attrib.items():
                    node_coordinates.append(value)
                if "easting" not in node.attrib:
                    node_coordinates.insert(2, "")
                if "northing" not in node.attrib:
                    node_coordinates.insert(3, "")
                if "height" not in node.attrib:
                    node_coordinates.insert(4, "")
                if "dy" not in node.attrib:
                    node_coordinates.insert(5, "")
                if "dx" not in node.attrib:
                    node_coordinates.insert(6, "")
                if "dh" not in node.attrib:
                    node_coordinates.insert(7, "")
                if "meanErrorA" not in node.attrib:
                    node_coordinates.insert(8, "")
                if "meanErrorB" not in node.attrib:
                    node_coordinates.insert(9, "")
                if "azimuthA" not in node.attrib:
                    node_coordinates.insert(10, "")
                if "meanErrorH" not in node.attrib:
                    node_coordinates.insert(11, "")
                if "planimetricElements" not in node.attrib:
                    node_coordinates.insert(12, "")
                if "altimetricElements" not in node.attrib:
                    node_coordinates.insert(13, "")
                list_coordinates.append(node_coordinates)
            self.resultat["coordinates"] = list_coordinates
        except:
            print("Result -> Error to import data from the node 'coordinates/point'")

    def get_external_reliability_apriori(self, root):
        """ Get the external reliability apriori nodes data """
        try:
            list_external_reliability_apriori = []
            for node in root.findall("externalReliabilityApriori/point"):
                node_external_reliability_apriori = []
                for key, value in node.attrib.items():
                    node_external_reliability_apriori.append(value)
                if "na" not in node.attrib:
                    node_external_reliability_apriori.insert(2, "")
                if "nb" not in node.attrib:
                    node_external_reliability_apriori.insert(3, "")
                if "azimuthN" not in node.attrib:
                    node_external_reliability_apriori.insert(4, "")
                if "nh" not in node.attrib:
                    node_external_reliability_apriori.insert(5, "")
                if "nrA" not in node.attrib:
                    node_external_reliability_apriori.insert(6, "")
                if "nrB" not in node.attrib:
                    node_external_reliability_apriori.insert(7, "")
                if "nrH" not in node.attrib:
                    node_external_reliability_apriori.insert(8, "")
                if "dy" not in node.attrib:
                    node_external_reliability_apriori.insert(9, "")
                if "dx" not in node.attrib:
                    node_external_reliability_apriori.insert(10, "")
                if "dh" not in node.attrib:
                    node_external_reliability_apriori.insert(11, "")
                if "meanErrorA" not in node.attrib:
                    node_external_reliability_apriori.insert(12, "")
                if "meanErrorB" not in node.attrib:
                    node_external_reliability_apriori.insert(13, "")
                if "azimuthA" not in node.attrib:
                    node_external_reliability_apriori.insert(14, "")
                if "meanErrorH" not in node.attrib:
                    node_external_reliability_apriori.insert(15, "")
                list_external_reliability_apriori.append(node_external_reliability_apriori)
            self.resultat["external_reliability_apriori"] = list_external_reliability_apriori
        except:
            print("Result -> Error to import data from the node 'externalReliabilityApriori/point'")

    def get_statistic(self, root):
        """ Get the statistic nodes data """
        try:
            search_page1_part1 = ["meanErrorQuotientWithoutRounding", "meanErrorQuotientFinalControl",
                                  "propThatQ", "observations", "unknowns", "blueundancy", "decimalPlaces", "maxMeanCoordError",
                                  "iterations", "maxCorrLastIteration", "interruptionLimit", "limitRobustComp"]
            dict_page1_part1_plani1 = {}  ## plani meanErrorQuotientWithoutRounding only !
            dict_page1_part1_plani2 = {}  ## plani everything else
            dict_page1_part1_altim1 = {}  ## altim meanErrorQuotientWithoutRounding only !
            dict_page1_part1_altim2 = {}  ## altim everything else
            for node in root.findall("page1/"):
                if node.tag in search_page1_part1:
                    if node.tag == "meanErrorQuotientWithoutRounding":
                        dict_page1_part1_plani1[node.tag] = node.attrib["plan"]
                        dict_page1_part1_altim1[node.tag] = node.attrib["alti"]
                    if node.tag == "propThatQ":
                        dict_page1_part1_plani2[node.tag] = node.attrib["plan"] + u" %"
                        dict_page1_part1_altim2[node.tag] = node.attrib["alti"] + u" %"
                    elif node.tag == "maxMeanCoordError" or node.tag == "maxCorrLastIteration" \
                            or node.tag == "interruptionLimit":
                        dict_page1_part1_plani2[node.tag] = node.attrib["plan"] + u" MM"
                        dict_page1_part1_altim2[node.tag] = node.attrib["alti"] + u" MM"
                    elif node.tag == "iterations":
                        dict_page1_part1_plani2[node.tag] = node.attrib["plan"] + " (" + node.attrib["planMax"] + ")"
                        dict_page1_part1_altim2[node.tag] = node.attrib["alti"] + " (" + node.attrib["altiMax"] + ")"
                    else:
                        dict_page1_part1_plani2[node.tag] = node.attrib["plan"]
                        dict_page1_part1_altim2[node.tag] = node.attrib["alti"]
            del dict_page1_part1_plani2["meanErrorQuotientWithoutRounding"]  ## Remove part already in dict_page1_part1_plani1
            del dict_page1_part1_altim2["meanErrorQuotientWithoutRounding"]  ## Remove part already in dict_page1_part1_altim1
            self.resultat["part1_plani1"] = dict_page1_part1_plani1
            self.resultat["part1_plani2"] = dict_page1_part1_plani2
            self.resultat["part1_altim1"] = dict_page1_part1_altim1
            self.resultat["part1_altim2"] = dict_page1_part1_altim2
        except:
            print("Result -> Error to import data from the node 'page1 -> 2 column part (top)'")

        # Part2 -> single column
        try:
            search_page1_part2 = ["calculationTime", "yxhAfterRounding", "stations", "observationLines"]
            dict_page1_part2 = {}
            for node in root.findall("page1/"):
                if node.tag in search_page1_part2:
                    if node.tag == "calculationTime":
                        dict_page1_part2[node.tag] = node.attrib["value"] + " SEC. (CPU)"
                    elif node.tag == "yxhAfterRounding":
                        dict_page1_part2[node.tag] = node.attrib["value"] + " DEC."
                    else:
                        dict_page1_part2[node.tag] = node.attrib["value"]
            self.resultat["part2"] = dict_page1_part2
        except:
            print("Result -> Error to import data from the node 'page1 -> 1 column part (bottom)'")

        # Files
        try:
            dict_page1_files = {}
            for node in root.findall("page1"):
                for elem in node.findall("files"):
                    for key, value in elem.attrib.items():
                        dict_page1_files[key] = value
            self.resultat["files"] = dict_page1_files
        except:
            print("Result -> Error to import data from the node 'page1/files'")

        # User
        try:
            for node in root.findall("page1"):
                for elem in node.findall("user"):
                    tag = elem.attrib["name"]
                    self.resultat["user"] = tag
        except:
            print("Result -> Error to import data from the node 'page1/user'")

        # Mean error observation group
        try:
            list_page1_err_moy_grp = []
            for node in root.findall("page1/observationGroups/observationGroup"):
                node_page1_err_moy_grp = []
                type = node.attrib["type"]
                if type == "distance" or type == "heightDiff":
                    for key, value in node.attrib.items():
                        if key == "type":
                            node_page1_err_moy_grp.append(value + "  [mm]")
                        else:
                            node_page1_err_moy_grp.append(value)
                elif type == "direction":
                    for key, value in node.attrib.items():
                        if key == "type":
                            node_page1_err_moy_grp.append(value + "    [cc]")
                        else:
                            node_page1_err_moy_grp.append(value)
                else:
                    for key, value in node.attrib.items():
                        node_page1_err_moy_grp.append(value)
                if "scaleNr" not in node.attrib:
                    node_page1_err_moy_grp.insert(1, "")
                if "scaleCorr" not in node.attrib:
                    node_page1_err_moy_grp.insert(2, "")
                if "scaleME" not in node.attrib:
                    node_page1_err_moy_grp.insert(3, "")
                if "addNr" not in node.attrib:
                    node_page1_err_moy_grp.insert(4, "")
                if "addCorr" not in node.attrib:
                    node_page1_err_moy_grp.insert(5, "")
                if "addME" not in node.attrib:
                    node_page1_err_moy_grp.insert(6, "")
                if "group" not in node.attrib:
                    node_page1_err_moy_grp.insert(7, "")
                list_page1_err_moy_grp.append(node_page1_err_moy_grp)
            self.resultat["page1_err_moy_grp"] = list_page1_err_moy_grp
        except:
            print("Result -> Error to import the mean error observation group in node 'page1'")

    def get_relative_ellipse(self, root):
        """ Get the relatives ellipses nodes data """
        try:
            list_rel_ellips = []
            for node in root.findall("relativeEllipses/ellipse"):
                node_rel_ellips = []
                for key, value in node.attrib.items():
                    node_rel_ellips.append(value)
                list_rel_ellips.append(node_rel_ellips)
            self.resultat["rel_ellips"] = list_rel_ellips
        except:
            print("Result -> Error to import data from the node 'relativeEllipses/ellipse'")

    def get_relative_rectangle(self, root):
        """ Get the relatives rectangles nodes data """
        try:
            list_rel_rectang = []
            for node in root.findall("relativeRectangles/rectangle"):
                node_rel_rectang = []
                for key, value in node.attrib.items():
                    node_rel_rectang.append(value)
                list_rel_rectang.append(node_rel_rectang)
            self.resultat["rel_rectang"] = list_rel_rectang
        except:
            print("Result -> Error to import data from the node 'relativeRectangles/rectangle'")


class tblResCreateWidget():
    """
    Create dynamically a QTableView for given node in the Ltop.prnx file
    Append these QTableView in the 'Result' pannel
    """
    def __init__(self, layout, model):
        self.layout = layout
        self.model = model
        self.create_widget()

    def create_widget(self):
        """ Create the table, fill with the data and append to the layout """
        table = QtWidgets.QTableView()

        table.verticalHeader().setDefaultSectionSize(20)
        table.verticalHeader().setVisible(False)

        # Apply the model to the table widget
        table.setModel(self.model)

        table.setFrameStyle(QtWidgets.QFrame.NoFrame)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        table.setSizePolicy(sizePolicy)
        table.setSizeAdjustPolicy(QtWidgets.QAbstractScrollArea.AdjustToContents)

        table.resizeColumnsToContents()

        # Add the widghet to the Ui
        self.layout.addWidget(table)


class resLabelValue():
    """
    Create dynamically a QLabel for each node of the Ltop.prnx file
    Append these QLabel in the 'Result' tab
    """
    def __init__(self, layout, data, alignment, font_wheight):
        self.layout = layout
        self.data = data
        self.alignment = alignment
        self.font_wheight = font_wheight
        self.create_widget()

    def create_widget(self):
        """ Create the QLabel, fill with the data and append to the layout """
        label = QtWidgets.QLabel()
        label.setText(self.data)

        if self.font_wheight == "Bold":
            font = QtGui.QFont()
            font.setBold(True)
            label.setFont(font)

        if self.alignment == "Left":
            label.setAlignment(Qt.AlignLeft)
        elif self.alignment == "Center":
            label.setAlignment(Qt.AlignCenter)
        else:
            label.setAlignment(Qt.AlignRight)

        self.layout.addWidget(label)


class tblResPlaniStochModel(QtCore.QAbstractTableModel):
    """ Model used to define the 'stochastic planimetric' table in the 'result' panel """

    # Class variable
    header_labels = ["Type", "Nom", "Groupe", "  Centr.\n[mm]", "A\n  [mm|cc]", "B\n  [mm/km]", u"C\n [mm/km²]", "E.M. PR 1KM\n[mm|cc]"]

    def __init__(self, data):
        super(tblResPlaniStochModel, self).__init__()
        self.data = data

    def data(self, index, role):
        if role == Qt.DisplayRole:
            # See below for the nested-list data structure.
            # .row() indexes into the outer list,
            # .column() indexes into the sub-list
            return self.data[index.row()][index.column()]
        if role == Qt.TextAlignmentRole:
            if index.column() == 0 or index.column() == 1:
                return Qt.AlignLeft | Qt.AlignVCenter
            elif index.column() == 2:
                return Qt.AlignCenter | Qt.AlignVCenter
            else:
                return Qt.AlignRight | Qt.AlignVCenter  ## Default alignment

    def rowCount(self, index):
        # The length of the outer list.
        return len(self.data)

    def columnCount(self, index):
        # The following takes the first sub-list, and returns
        # the length (only works if all rows are an equal length)
        return len(self.data[0])

    def headerData(self, section, orientation, role=Qt.DisplayRole):
        """ Display the header column and set the alignements """
        if role == Qt.DisplayRole and orientation == Qt.Horizontal:
            return self.header_labels[section]
        if role == Qt.TextAlignmentRole:
            if section == 0 or section == 1:
                return Qt.AlignLeft
            elif section == 2:
                return Qt.AlignHCenter | Qt.AlignTop
            else:
                return Qt.AlignRight
        return QtCore.QAbstractTableModel.headerData(self, section, orientation, role)


class tblResAltiStochModel(QtCore.QAbstractTableModel):
    """ Model used to define the 'stochastic altimetric' table in the 'result' panel """

    # Class variable
    header_labels = ["Type", " D CALC.\n[mm]", "  VERT.\n[cc]", "  HI-HS\n[mm]", "  C REFR"]

    def __init__(self, data):
        super(tblResAltiStochModel, self).__init__()
        self.data = data

    def data(self, index, role):
        if role == Qt.DisplayRole:
            # See below for the nested-list data structure.
            # .row() indexes into the outer list,
            # .column() indexes into the sub-list
            return self.data[index.row()][index.column()]
        if role == Qt.TextAlignmentRole:
            if index.column() == 0:
                return Qt.AlignLeft | Qt.AlignVCenter
            else:
                return Qt.AlignRight | Qt.AlignVCenter  ## Default alignment

    def rowCount(self, index):
        # The length of the outer list.
        return len(self.data)

    def columnCount(self, index):
        # The following takes the first sub-list, and returns
        # the length (only works if all rows are an equal length)
        return len(self.data[0])

    def headerData(self, section, orientation, role=Qt.DisplayRole):
        """ Display the header column and set the alignements """
        if role == Qt.DisplayRole and orientation == Qt.Horizontal:
            return self.header_labels[section]
        if role == Qt.TextAlignmentRole:
            if section == 0:
                return Qt.AlignLeft
            else:
                return Qt.AlignRight
        return QtCore.QAbstractTableModel.headerData(self, section, orientation, role)


class tblResExternalReliabilityModel(QtCore.QAbstractTableModel):
    """ Model used to define the 'external relibility' table in the 'result' panel """

    # Class variable
    header_labels = ["Point  ", "Type TC  ", "NA\n  [mm]", "NB\n  [mm]", "GIS(NA)\n  [gon]",
                     "NH\n  [mm]", "  NO.A", "  NO.B", "  NO.H", "DY\n  [mm]", "DX\n  [mm]",
                     "DH\n  [mm]", "EMA\n  [mm]", "EMB\n  [mm]", "GISA\n  [gon]", "EMH\n  [mm]"]

    def __init__(self, data):
        super(tblResExternalReliabilityModel, self).__init__()
        self.data = data

    def data(self, index, role):
        if role == Qt.DisplayRole:
            # See below for the nested-list data structure.
            # .row() indexes into the outer list,
            # .column() indexes into the sub-list
            return self.data[index.row()][index.column()]
        if role == Qt.TextAlignmentRole:
            if index.column() == 0 or index.column() == 1:
                return Qt.AlignLeft | Qt.AlignVCenter
            else:
                return Qt.AlignRight | Qt.AlignVCenter  ## Default alignment
        if role == Qt.ForegroundRole:
            value = self.data[index.row()][index.column()]
            if value == "infinite":
                return QtGui.QColor("blue")

    def rowCount(self, index):
        # The length of the outer list.
        return len(self.data)

    def columnCount(self, index):
        # The following takes the first sub-list, and returns
        # the length (only works if all rows are an equal length)
        return len(self.data[0])

    def headerData(self, section, orientation, role=Qt.DisplayRole):
        """ Display the header column and set the alignements """
        if role == Qt.DisplayRole and orientation == Qt.Horizontal:
            return self.header_labels[section]
        if role == Qt.TextAlignmentRole:
            if section == 0 or section == 1:
                return Qt.AlignLeft
            else:
                return Qt.AlignRight
        return QtCore.QAbstractTableModel.headerData(self, section, orientation, role)


class tblResErrorsModel(QtCore.QAbstractTableModel):
    """ Model used to define the 'ltop errors' table in the 'result' panel """

    # Class variable
    header_labels = ["Code  ", "Message  "]

    def __init__(self, data):
        super(tblResErrorsModel, self).__init__()
        self.data = data

    def data(self, index, role):
        if role == Qt.DisplayRole:
            # See below for the nested-list data structure.
            # .row() indexes into the outer list,
            # .column() indexes into the sub-list
            return self.data[index.row()][index.column()]
        if role == Qt.TextAlignmentRole:
            return Qt.AlignLeft | Qt.AlignVCenter

    def rowCount(self, index):
        # The length of the outer list.
        return len(self.data)

    def columnCount(self, index):
        # The following takes the first sub-list, and returns
        # the length (only works if all rows are an equal length)
        return len(self.data[0])

    def headerData(self, section, orientation, role=Qt.DisplayRole):
        """ Display the header column and set the alignements """
        if role == Qt.DisplayRole and orientation == Qt.Horizontal:
            return self.header_labels[section]
        if role == Qt.TextAlignmentRole:
            return Qt.AlignLeft
        return QtCore.QAbstractTableModel.headerData(self, section, orientation, role)


class tblResCoordinatesModel(QtCore.QAbstractTableModel):
    """ Model used to define the 'coordinates' table in the 'result' panel """

    # Class variable
    header_labels = ["Point  ", "Type  ", "Y\n  [m]", "X\n  [m]", "H\n  [m]",
                     "DY\n  [mm]", "DX\n  [mm]", "DH\n  [mm]", "EMA\n  [mm]",
                     "EMB\n  [mm]", "GISA\n  [gon]", "EMH\n  [mm]", "ELEM.\n  PLAN.", "MES.\n  ALT."]

    def __init__(self, data):
        super(tblResCoordinatesModel, self).__init__()
        self.data = data

    def data(self, index, role):
        if role == Qt.DisplayRole:
            # See below for the nested-list data structure.
            # .row() indexes into the outer list,
            # .column() indexes into the sub-list
            return self.data[index.row()][index.column()]
        if role == Qt.TextAlignmentRole:
            if index.column() == 0 or index.column() == 1:
                return Qt.AlignLeft | Qt.AlignVCenter
            else:
                return Qt.AlignRight | Qt.AlignVCenter  ## Default alignment

    def rowCount(self, index):
        # The length of the outer list.
        return len(self.data)

    def columnCount(self, index):
        # The following takes the first sub-list, and returns
        # the length (only works if all rows are an equal length)
        return len(self.data[0])

    def headerData(self, section, orientation, role=Qt.DisplayRole):
        """ Display the header column and set the alignements """
        if role == Qt.DisplayRole and orientation == Qt.Horizontal:
            return self.header_labels[section]
        if role == Qt.TextAlignmentRole:
            if section == 0 or section == 1:
                return Qt.AlignLeft
            else:
                return Qt.AlignRight
        return QtCore.QAbstractTableModel.headerData(self, section, orientation, role)


class tblResStatErrMoyGrpModel(QtCore.QAbstractTableModel):
    """ Model used to define the 'statistical mean error' table in the 'result' panel """

    # Class variable
    header_labels = ["Type", "Ech.", " Corr. ech.\n[ppm]", " EM ech.\n[ppm]", "Add.",
                     " Corr. add.\n[mm]", " EM ech.\n[mm]", "Groupe", " Nbr.",
                     " A priori", " Finales", " Quotient", " Redond."]

    def __init__(self, data):
        super(tblResStatErrMoyGrpModel, self).__init__()
        self.data = data

    def data(self, index, role):
        if role == Qt.DisplayRole:
            # See below for the nested-list data structure.
            # .row() indexes into the outer list,
            # .column() indexes into the sub-list
            return self.data[index.row()][index.column()]
        if role == Qt.TextAlignmentRole:
            if index.column() == 0:
                return Qt.AlignLeft | Qt.AlignVCenter
            elif index.column() == 1 or index.column() == 4 or index.column() == 7:
                return Qt.AlignCenter | Qt.AlignVCenter
            else:
                return Qt.AlignRight | Qt.AlignVCenter  ## Default alignment

    def rowCount(self, index):
        # The length of the outer list.
        return len(self.data)

    def columnCount(self, index):
        # The following takes the first sub-list, and returns
        # the length (only works if all rows are an equal length)
        return len(self.data[0])

    def headerData(self, section, orientation, role=Qt.DisplayRole):
        """ Display the header column and set the alignements """
        if role == Qt.DisplayRole and orientation == Qt.Horizontal:
            return self.header_labels[section]
        if role == Qt.TextAlignmentRole:
            if section == 0:
                return Qt.AlignLeft
            elif section == 1 or section == 4 or section == 7:
                return Qt.AlignHCenter | Qt.AlignTop
            else:
                return Qt.AlignRight
        return QtCore.QAbstractTableModel.headerData(self, section, orientation, role)


class tblResAltiStationModel(QtCore.QAbstractTableModel):
    """ Model used to define the 'altimetric station' table in the 'result' panel """

    # Class variable
    header_labels = [" N. OBS", "Point ", " Type", " Var. ", " D. Niv.\n[m]",
                     " Contr.\n[mm]", " V\n[mm]", " E.M.\n[mm]", u" ZI\n[%]",
                     " NABLA\n[cc|mm]", " Rob.", " WI", " GI\n[mm]", " Dist.\n[m]",
                     " Vert.\n[gon]", u" Réd.\n[cc]", " Hi\n[m]", " Hs\n[m]", " Date"]

    def __init__(self, data, val_wi):
        super(tblResAltiStationModel, self).__init__()
        self.data = data
        self.val_wi = val_wi

    def data(self, index, role):
        if role == Qt.DisplayRole:
            # See below for the nested-list data structure.
            # .row() indexes into the outer list,
            # .column() indexes into the sub-list
            return self.data[index.row()][index.column()]
        if role == Qt.TextAlignmentRole:
            if index.column() == 1:  ## 'Point' attribut
                return Qt.AlignLeft | Qt.AlignVCenter
            elif index.column() == 3:  ## 'Variable' attribut
                return Qt.AlignCenter | Qt.AlignVCenter
            else:
                return Qt.AlignRight | Qt.AlignVCenter  ## Default alignment
        if role == Qt.ForegroundRole:
            if index.column() == 8:  ## Zi column
                value = self.data[index.row()][index.column()]
                if float(value) < 20:
                    return QtGui.QColor("blue")
        if role == Qt.ForegroundRole and index.column() == 11:  ## Wi column
            value = self.data[index.row()][index.column()]
            if gt_isfloat(value):
                if abs(float(value)) > float(self.val_wi):
                    return QtGui.QColor("red")

    def rowCount(self, index):
        # The length of the outer list.
        return len(self.data)

    def columnCount(self, index):
        # The following takes the first sub-list, and returns
        # the length (only works if all rows are an equal length)
        return len(self.data[0])

    def headerData(self, section, orientation, role=Qt.DisplayRole):
        """ Display the header column and set the alignements """
        if role == Qt.DisplayRole and orientation == Qt.Horizontal:
            return self.header_labels[section]
        if role == Qt.TextAlignmentRole:
            if section == 1:  ## 'Point' attribut
                return Qt.AlignLeft
            elif section == 3:  ## 'Variable' attribut
                return Qt.AlignHCenter | Qt.AlignTop
            else:
                return Qt.AlignRight
        return QtCore.QAbstractTableModel.headerData(self, section, orientation, role)


class tblResPlaniStationDistanceModel(QtCore.QAbstractTableModel):
    """ Model used to define the 'planimetric distance' table in the 'result' panel """

    # Class variable
    header_labels = [" N. OBS", "Point ", " Type", " Var. ", " Obs\n[m]", " Mut.",
                     " Grp.", "Corr.\n[mm]", " V\n[mm]", " E.M.\n[mm]", u" ZI\n[%]",
                     " NABLA\n[mm]", " Rob.", " WI", " GI\n[mm]", " Gis.\n[gon]", " Dist.\n[m]"]

    def __init__(self, data, val_wi):
        super(tblResPlaniStationDistanceModel, self).__init__()
        self.data = data
        self.val_wi = val_wi

    def data(self, index, role):
        if role == Qt.DisplayRole:
            # See below for the nested-list data structure.
            # .row() indexes into the outer list,
            # .column() indexes into the sub-list
            return self.data[index.row()][index.column()]
        if role == Qt.TextAlignmentRole:
            if index.column() == 1:  ## 'Point' attribut
                return Qt.AlignLeft | Qt.AlignVCenter
            elif index.column() == 3 or index.column() == 5:  ## 'Variable' & 'mutualObs' attribut
                return Qt.AlignCenter | Qt.AlignVCenter
            else:
                return Qt.AlignRight | Qt.AlignVCenter  ## Default alignment
        if role == Qt.ForegroundRole:
            if index.column() == 10:  ## Zi column
                value = self.data[index.row()][index.column()]
                if float(value) < 20:
                    return QtGui.QColor("blue")
        if role == Qt.ForegroundRole and index.column() == 13:  ## Wi column
            value = self.data[index.row()][index.column()]
            if gt_isfloat(value):
                if abs(float(value)) > float(self.val_wi):
                    return QtGui.QColor("red")

    def rowCount(self, index):
        # The length of the outer list.
        return len(self.data)

    def columnCount(self, index):
        # The following takes the first sub-list, and returns
        # the length (only works if all rows are an equal length)
        return len(self.data[0])

    def headerData(self, section, orientation, role=Qt.DisplayRole):
        """ Display the header column and set the alignements """
        if role == Qt.DisplayRole and orientation == Qt.Horizontal:
            return self.header_labels[section]
        if role == Qt.TextAlignmentRole:
            if section == 1 or section == 5:  ## 'Point' & 'mutualObs' attribut
                return Qt.AlignLeft
            elif section == 3:  ## 'Variable' attribut
                return Qt.AlignHCenter | Qt.AlignTop
            else:
                return Qt.AlignRight
        return QtCore.QAbstractTableModel.headerData(self, section, orientation, role)


class tblResPlaniStationDirectionModel(QtCore.QAbstractTableModel):
    """ Model used to define the 'planimetric direction' table in the 'result' panel """

    # Class variable
    header_labels = [" N. OBS", "Point ", " Type", " Var. ", " Or.\n[gon]", " Mut.",
                     " Grp.", "Corr.\n[cc]", " V\n[cc]", " E.M.\n[cc]", u" ZI\n[%]",
                     " NABLA\n[cc]", " Rob.", " WI", " GI\n[cc]", " Gis.\n[gon]",
                     " Dist.\n[m]", " E. LAT.\n[mm]"]

    def __init__(self, data, val_wi):
        super(tblResPlaniStationDirectionModel, self).__init__()
        self.data = data
        self.val_wi = val_wi

    def data(self, index, role):
        if role == Qt.DisplayRole:
            # See below for the nested-list data structure.
            # .row() indexes into the outer list,
            # .column() indexes into the sub-list
            return self.data[index.row()][index.column()]
        if role == Qt.TextAlignmentRole:
            if index.column() == 1:  ## 'Point' attribut
                return Qt.AlignLeft | Qt.AlignVCenter
            elif index.column() == 3 or index.column() == 5:  ## 'Variable' & 'mutualObs' attribut
                return Qt.AlignCenter | Qt.AlignVCenter
            else:
                return Qt.AlignRight | Qt.AlignVCenter  ## Default alignment
        if role == Qt.ForegroundRole and index.column() == 10:  ## Zi column
            value = self.data[index.row()][index.column()]
            if float(value) < 20:
                return QtGui.QColor("blue")
        if role == Qt.ForegroundRole and index.column() == 13:  ## Wi column
            value = self.data[index.row()][index.column()]
            if gt_isfloat(value):
                if abs(float(value)) > float(self.val_wi):
                    return QtGui.QColor("red")

    def rowCount(self, index):
        # The length of the outer list.
        return len(self.data)

    def columnCount(self, index):
        # The following takes the first sub-list, and returns
        # the length (only works if all rows are an equal length)
        return len(self.data[0])

    def headerData(self, section, orientation, role=Qt.DisplayRole):
        """ Display the header column and set the alignements """
        if role == Qt.DisplayRole and orientation == Qt.Horizontal:
            return self.header_labels[section]
        if role == Qt.TextAlignmentRole:
            if section == 1 or section == 5:  ## 'Point' & 'mutualObs' attribut
                return Qt.AlignLeft
            elif section == 3:  ## 'Variable' attribut
                return Qt.AlignHCenter | Qt.AlignTop
            else:
                return Qt.AlignRight
        return QtCore.QAbstractTableModel.headerData(self, section, orientation, role)


class tblResRelEllipsModel(QtCore.QAbstractTableModel):
    """ Model used to define the 'relative ellipse' table in the 'result' panel """

    # Class variable
    header_labels = ["Point 1 ", "Type 1 ", "Point 2 ", "Type 2 ", " EMA\n[mm]", " EMB\n[mm]", " EMGIS\n[gon]"]

    def __init__(self, data):
        super(tblResRelEllipsModel, self).__init__()
        self.data = data

    def data(self, index, role):
        if role == Qt.DisplayRole:
            # See below for the nested-list data structure.
            # .row() indexes into the outer list,
            # .column() indexes into the sub-list
            return self.data[index.row()][index.column()]
        if role == Qt.TextAlignmentRole:
            if index.column() == 4 or index.column() == 5 or \
                    index.column() == 6:  ## 'meanErrorA, meanErrorB, azimuthA' attribut
                return Qt.AlignRight | Qt.AlignVCenter
            else:
                return Qt.AlignLeft | Qt.AlignVCenter  ## Default alignment

    def rowCount(self, index):
        # The length of the outer list.
        return len(self.data)

    def columnCount(self, index):
        # The following takes the first sub-list, and returns
        # the length (only works if all rows are an equal length)
        return len(self.data[0])

    def headerData(self, section, orientation, role=Qt.DisplayRole):
        """ Display the header column and set the alignements """
        if role == Qt.DisplayRole and orientation == Qt.Horizontal:
            return self.header_labels[section]
        if role == Qt.TextAlignmentRole:
            if section == 4 or section == 5 or section == 6:  ## 'meanErrorA, meanErrorB, azimuthA' attribut
                return Qt.AlignRight
            else:
                return Qt.AlignLeft  ## Default alignment
        return QtCore.QAbstractTableModel.headerData(self, section, orientation, role)


class tblResRelRectangModel(QtCore.QAbstractTableModel):
    """ Model used to define the 'relative fiability rectangle' table in the 'result' panel """

    # Class variable
    header_labels = ["Point 1 ", "Type 1 ", "Point 2 ", "Type 2 ", " NA\n[mm]",
                     " NB\n[mm]", " GIS(NA)\n[gon]", "NO.A ", "NO.B "]

    def __init__(self, data):
        super(tblResRelRectangModel, self).__init__()
        self.data = data

    def data(self, index, role):
        if role == Qt.DisplayRole:
            # See below for the nested-list data structure.
            # .row() indexes into the outer list,
            # .column() indexes into the sub-list
            return self.data[index.row()][index.column()]
        if role == Qt.TextAlignmentRole:
            if index.column() == 4 or index.column() == 5 or \
                    index.column() == 6:  ## 'NA, NB, azimuthA' attribut
                return Qt.AlignRight | Qt.AlignVCenter
            else:
                return Qt.AlignLeft | Qt.AlignVCenter  ## Default alignment
        if role == Qt.ForegroundRole:
            value = self.data[index.row()][index.column()]
            if value == "INFINI":
                return QtGui.QColor("blue")

    def rowCount(self, index):
        # The length of the outer list.
        return len(self.data)

    def columnCount(self, index):
        # The following takes the first sub-list, and returns
        # the length (only works if all rows are an equal length)
        return len(self.data[0])

    def headerData(self, section, orientation, role=Qt.DisplayRole):
        if role == Qt.DisplayRole and orientation == Qt.Horizontal:
            return self.header_labels[section]
        if role == Qt.TextAlignmentRole:
            if section == 4 or section == 5 or section == 6:  ## 'NA, NB, azimuthA' attribut
                return Qt.AlignRight
            else:
                return Qt.AlignLeft  ## Default alignment
        return QtCore.QAbstractTableModel.headerData(self, section, orientation, role)


class tblResListWiModel(QtCore.QAbstractTableModel):
    """ Model used to define the 'wi list' table in the 'result' panel """

    # Class variable
    header_labels = [" Rang", " N. OBS ", "Type", " ABS (WI)"]

    def __init__(self, data):
        super(tblResListWiModel, self).__init__()
        self.data = data

    def data(self, index, role):
        if role == Qt.DisplayRole:
            # See below for the nested-list data structure.
            # .row() indexes into the outer list,
            # .column() indexes into the sub-list
            return self.data[index.row()][index.column()]
        if role == Qt.TextAlignmentRole:
            if index.column() == 2:  ## 'type' attribut
                return Qt.AlignCenter | Qt.AlignVCenter
            else:
                return Qt.AlignRight | Qt.AlignVCenter  ## Default alignment

    def rowCount(self, index):
        # The length of the outer list.
        return len(self.data)

    def columnCount(self, index):
        # The following takes the first sub-list, and returns
        # the length (only works if all rows are an equal length)
        return len(self.data[0])

    def headerData(self, section, orientation, role=Qt.DisplayRole):
        if role == Qt.DisplayRole and orientation == Qt.Horizontal:
            return self.header_labels[section]
        if role == Qt.TextAlignmentRole:
            if section == 2:  ## 'type' attribut
                return Qt.AlignCenter
            else:
                return Qt.AlignRight  ## Default alignment
        return QtCore.QAbstractTableModel.headerData(self, section, orientation, role)


class getPrnxDataQgis:
    """
    Purpose :
        - Extract the ellipses/rectangle data only from the Ltop.prnx file (xml format)
        - Will be displayed as layers in the Qgis canevas from the 'qltop_dockwidget.py' functions
    Input :
        - Ltop.prnx file
    Output :
        - Memory layers in the Qgis canevas
    """

    # Class variable
    dict_canevas = {"name": "", "type": "", "na": "", "nb": "", "azimuthN": "",
                    "nh": "", "nrA": "", "nrB": "", "nrH": "", "dy": "", "dx": "",
                    "dh": "", "meanErrorA": "", "meanErrorB": "", "azimuthA": "",
                    "meanErrorH": "", "easting": "", "northing": ""}

    def __init__(self, prnx_file):
        self.prnx_file = prnx_file
        self.root = ET.parse(self.prnx_file).getroot()
        self.prnx_coord = self.get_prnx_data("coordinates/point")
        # Extract nodes from the Ltop.prnx file
        self.prnx_exter_rel = self.get_prnx_data("externalReliabilityApriori/point")
        # Concatenate the coordinates to the previous lists
        self.modif_list = self.assign_canevas_dict(self.extract_data_to_display())

    def get_prnx_data(self, node_path):
        """
        Get the nodes data from the Ltop.prnx file to build the geometry in Qgis
        -> coordinates from the 'coordinates/point' nodes
        -> NA, NB, GIS NA, EMA, EMB, EM GIS from the 'externalReliabilityApriori/point' nodes
        """
        try:
            dict_data = {}
            for node in self.root.findall(node_path):
                point_name = node.attrib["name"]
                dict_data[point_name] = node.attrib
            return dict_data
        except:
            print("Result -> Failed to retrieve the data from the Ltop.prnx file")

    def extract_data_to_display(self):
        """ Add the coordinates to the external reliability list """
        try:
            if self.prnx_coord and self.prnx_exter_rel:
                modif_list = self.prnx_exter_rel
                # Add the coordinates
                for point in self.prnx_exter_rel:
                    east_val = self.prnx_coord[point]["easting"]
                    north_val = self.prnx_coord[point]["northing"]
                    modif_list[point]["easting"] = east_val
                    modif_list[point]["northing"] = north_val
                return modif_list
        except:
            print("Result -> Failed to add coordinates to the ellipses/rectangle external reliability list")

    @classmethod
    def assign_canevas_dict(cls, points):
        """ Fill the canevas dictionary with the extracted data """
        new_list = []  ## return list
        for point in points:
            new_dict = cls.dict_canevas.copy()
            for key, value in points[point].items():
                new_dict[key] = value
            new_list.append(new_dict)
        return new_list


class displayEllipseError:
    """
        Draw the error ellipses in the Qgis canvas
        Input : Data from the Ltop.prnx file (Coordinates, EMA, EMB, rotation)
        Output : Qgis layer
    """

    # Class variables
    layer_name = "qltop_ellipse_erreur"
    qml_style_ellipse = "style_qltop_ellipse.qml"

    def __init__(self, list_points, epsg, scale):
        self.list_points = list_points
        self.epsg = epsg
        if not scale:
            self.scale = 1000  ## Default value if empty
        elif scale == "e":    ## Test if string to manage the Euler number
            self.scale = 2.71828
        else:
            self.scale = float(scale)
        self.create_ellipse_layer()

    def create_ellipse_layer(self):
        if self.list_points:

            # create the layer
            vl = QgsVectorLayer("Polygon?crs=" + self.epsg, self.layer_name, "memory")
            pr = vl.dataProvider()

            # add fields
            pr.addAttributes([QgsField("Nom", QVariant.String, "string"),
                              QgsField("Type",  QVariant.String, "string"),
                              QgsField("NA",  QVariant.String, "string"),
                              QgsField("NB", QVariant.String, "string"),
                              QgsField("Gis N",  QVariant.String, "string"),
                              QgsField("NH",  QVariant.String, "string"),
                              QgsField("nrA",  QVariant.String, "string"),
                              QgsField("nrB",  QVariant.String, "string"),
                              QgsField("nrH",  QVariant.String, "string"),
                              QgsField("DY",  QVariant.String, "string"),
                              QgsField("DX",  QVariant.String, "string"),
                              QgsField("DH",  QVariant.String, "string"),
                              QgsField("EMA",  QVariant.String, "string"),
                              QgsField("EMB",  QVariant.String, "string"),
                              QgsField("Gis EM",  QVariant.String, "string"),
                              QgsField("EMH",  QVariant.String, "string"),
                              QgsField("Est",  QVariant.String, "string"),
                              QgsField("Nord",  QVariant.String, "string")])

            vl.updateFields()  # tell the vector layer to fetch changes from the provider

            # add features
            for point in self.list_points:

                # Test if the attributes allow to create a geometry
                if point["meanErrorA"] and point["meanErrorB"] and point["azimuthA"] and \
                   point["easting"] and point["northing"] and point["dy"] and point["dx"]:
                   
                    if gt_isfloat(point["dy"]) and gt_isfloat(point["dx"]):
                        pos_y = float(point["easting"]) - float(point["dy"])/1000
                        pos_x = float(point["northing"]) - float(point["dx"])/1000
                    else:
                        pos_y = float(point["easting"])
                        pos_x = float(point["northing"])
                    ema = float(point["meanErrorA"])/1000 * self.scale
                    emb = float(point["meanErrorB"])/1000 * self.scale
                    # Qgs Ellipse rotation = Start from the North to the first quadrant in degree
                    gis = float(point["azimuthA"]) * 9/10  ## With grad to degree conversion

                    geom = QgsEllipse(QgsPoint(pos_y, pos_x), ema, emb, gis)

                    fet = QgsFeature()
                    fet.setGeometry(geom.toPolygon())
                    fet.setAttributes(list(point.values()))
                    pr.addFeatures([fet])

            # add preconfigublue qgis.qml style file
            plugin_folder = os.path.dirname(os.path.dirname(__file__))
            qml_file = Path(plugin_folder) / "qml" / self.qml_style_ellipse
            if qml_file.is_file():  # Test if file exist, avoid error if he is missing
                vl.loadNamedStyle(str(qml_file))

            # update layer's extent when new features have been added
            vl.updateExtents()

            # zoom to the layer extent
            canvas = iface.mapCanvas()
            canvas.setExtent(vl.extent())

            # Show in project
            self.rmv_old_qgs_ellipse_layer()
            QgsProject.instance().addMapLayer(vl)

    @staticmethod
    def rmv_old_qgs_ellipse_layer():
        """ Remove preexisting ellipse layer """
        try:
            names = [layer.name() for layer in QgsProject.instance().mapLayers().values()]
            qgs_instance = QgsProject.instance()
            for name in names:
                if name == displayEllipseError.layer_name:
                    qgs_instance.removeMapLayer(qgs_instance.mapLayersByName(name)[0].id())
        except:
            print("Result -> Failed to remove the preexisting ellipse layer")


class displayFiabilityRectangle:
    """
        Draw the reliability rectangles in the Qgis canvas
        Input : Data from the Ltop.prnx file (Coordinates, NA, NB, Rotation GIS NA)
        Output : Qgis layer
    """

    # Class variables
    layer_name = u"qltop_rectangle_fiabilité"
    qml_style_rectangle = "style_qltop_rectangle.qml"

    def __init__(self, list_points, epsg, scale):
        self.list_points = list_points
        self.epsg = epsg
        if not scale:
            self.scale = 100  ## Default value if empty
        elif scale == "e":  ## Test if string to manage the Euler number
            self.scale = 2.71828
        else:
            self.scale = float(scale)
        self.create_rectangle_layer()

    def create_rectangle_layer(self):
        if self.list_points:

            # create the layer
            vl = QgsVectorLayer("Polygon?crs=" + self.epsg, self.layer_name, "memory")
            pr = vl.dataProvider()

            # add fields
            pr.addAttributes([QgsField("Nom", QVariant.String, "string"),
                              QgsField("Type",  QVariant.String, "string"),
                              QgsField("NA",  QVariant.String, "string"),
                              QgsField("NB", QVariant.String, "string"),
                              QgsField("Gis N",  QVariant.String, "string"),
                              QgsField("NH",  QVariant.String, "string"),
                              QgsField("nrA",  QVariant.String, "string"),
                              QgsField("nrB",  QVariant.String, "string"),
                              QgsField("nrH",  QVariant.String, "string"),
                              QgsField("DY",  QVariant.String, "string"),
                              QgsField("DX",  QVariant.String, "string"),
                              QgsField("DH",  QVariant.String, "string"),
                              QgsField("EMA",  QVariant.String, "string"),
                              QgsField("EMB",  QVariant.String, "string"),
                              QgsField("Gis EM",  QVariant.String, "string"),
                              QgsField("EMH",  QVariant.String, "string"),
                              QgsField("Est",  QVariant.String, "string"),
                              QgsField("Nord",  QVariant.String, "string")])

            vl.updateFields()  # tell the vector layer to fetch changes from the provider

            # add features
            for point in self.list_points:

                # Test if the attributes allow to create a geometry
                if point["na"] and point["nb"] and point["azimuthN"] and \
                   point["easting"] and point["northing"] and point["dy"] and point["dx"]:

                    # NA, NB
                    na = 1 if point["na"] == "infinite" else float(point["na"])/1000 * self.scale
                    nb = 1 if point["nb"] == "infinite" else float(point["nb"])/1000 * self.scale
                    # Rotation
                    gis = float(point["azimuthN"]) * 9/10  ## With grad to degree conversion
                    # Center point
                    if gt_isfloat(point["dy"]) and gt_isfloat(point["dx"]):
                        pos_y = float(point["easting"]) - float(point["dy"])/1000
                        pos_x = float(point["northing"]) - float(point["dx"])/1000
                    else:
                        pos_y = float(point["easting"])
                        pos_x = float(point["northing"])
                    center = QgsPointXY(pos_y, pos_x)
                    # Rectangle ends
                    min_y = pos_y - nb
                    max_y = pos_y + nb
                    min_x = pos_x - na
                    max_x = pos_x + na
                    point1 = QgsPointXY(min_y, min_x)
                    point2 = QgsPointXY(max_y, max_x)

                    # Rectangle geometry
                    rectangle = QgsRectangle(point1, point2).asWktPolygon()
                    geom = QgsGeometry.fromWkt(rectangle)
                    geom.rotate(gis, center)

                    fet = QgsFeature()
                    fet.setGeometry(geom)
                    fet.setAttributes(list(point.values()))

                    pr.addFeatures([fet])

            # add preconfigublue qgis.qml style file
            plugin_folder = os.path.dirname(os.path.dirname(__file__))
            qml_file = Path(plugin_folder) / "qml" / self.qml_style_rectangle
            if qml_file.is_file():  # Test if file exist, avoid error if he is missing
                vl.loadNamedStyle(str(qml_file))

            # update layer's extent when new features have been added
            vl.updateExtents()

            # zoom to the layer extent
            canvas = iface.mapCanvas()
            canvas.setExtent(vl.extent())

            # Show in project
            self.rmv_old_qgs_rectangle_layer()
            QgsProject.instance().addMapLayer(vl)

    @staticmethod
    def rmv_old_qgs_rectangle_layer():
        """ Remove preexisting rectangle fiability layer """
        try:
            names = [layer.name() for layer in QgsProject.instance().mapLayers().values()]
            qgs_instance = QgsProject.instance()
            for name in names:
                if name == displayFiabilityRectangle.layer_name:
                    qgs_instance.removeMapLayer(qgs_instance.mapLayersByName(name)[0].id())
        except:
            print("Result -> Failed to remove the preexisting fiability rectangle layer")
